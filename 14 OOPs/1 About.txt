ğŸŸ¦ OBJECT-ORIENTED PROGRAMMING (OOPs) IN JAVA â€“ DETAILED SUMMARY ğŸŸ¦

1ï¸âƒ£ CLASS:
ğŸ”¹ A blueprint/template that defines attributes (variables) and behaviors (methods).
ğŸ”¹ Doesnâ€™t consume memory until an object is created.
ğŸ”¸ Example:
    class Car {
        String color;
        void drive() {
            System.out.println("Driving...");
        }
    }

2ï¸âƒ£ OBJECT:
ğŸ”¹ A real-world entity created from a class.
ğŸ”¹ It has its own state (data) and behavior (methods).
ğŸ”¸ Example:
    Car c = new Car();

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸŸ¨ FOUR PILLARS OF OOPs:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

3ï¸âƒ£ ENCAPSULATION:
ğŸ”¹ Wrapping data and methods into a single unit (class).
ğŸ”¹ Helps in data hiding using `private` access modifier.
ğŸ”¹ Access is provided via `getters` and `setters`.
ğŸ”¸ Example:
    class Student {
        private int marks;
        public void setMarks(int m) { marks = m; }
        public int getMarks() { return marks; }
    }

4ï¸âƒ£ INHERITANCE:
ğŸ”¹ Mechanism where one class acquires properties of another.
ğŸ”¹ Promotes reusability and method overriding.
ğŸ”¸ Keywords: `extends`
ğŸ”¸ Types: Single, Multilevel, Hierarchical
ğŸ”¸ Example:
    class Animal { void eat() {} }
    class Dog extends Animal { void bark() {} }

5ï¸âƒ£ POLYMORPHISM:
ğŸ”¹ Ability to take many forms.
ğŸ”¹ Types:
   âœ… Compile-Time (Method Overloading): Same method name, different parameters.
   âœ… Run-Time (Method Overriding): Same method name, same parameters, different classes.
ğŸ”¸ Example (Overloading):
    int add(int a, int b) {...}
    double add(double a, double b) {...}
ğŸ”¸ Example (Overriding):
    class A { void show() {} }
    class B extends A { void show() {} }

6ï¸âƒ£ ABSTRACTION:
ğŸ”¹ Hiding internal details and showing only the necessary functionality.
ğŸ”¹ Achieved using:
   âœ… Abstract Class (`abstract class`)
   âœ… Interface (`interface`)
ğŸ”¸ Abstract class can have both abstract & concrete methods.
ğŸ”¸ Interface contains only abstract methods (Java 8+ allows default/static methods).
ğŸ”¸ Example:
    abstract class Shape { abstract void draw(); }

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸŸ© ADDITIONAL OOP CONCEPTS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

7ï¸âƒ£ INTERFACE:
ğŸ”¹ A contract for classes to implement.
ğŸ”¹ Used for full abstraction & multiple inheritance.
ğŸ”¸ Syntax:
    interface Vehicle { void start(); }
    class Car implements Vehicle { public void start() {} }

8ï¸âƒ£ CONSTRUCTOR:
ğŸ”¹ Special method that runs when an object is created.
ğŸ”¹ Same name as class, no return type.
ğŸ”¸ Types: Default, Parameterized, Copy
ğŸ”¸ Example:
    class Person {
        Person() {
            System.out.println("Constructor called");
        }
    }

9ï¸âƒ£ THIS KEYWORD:
ğŸ”¹ Refers to the current object.
ğŸ”¹ Resolves naming conflicts between instance and local variables.
ğŸ”¸ Example:
    class Test {
        int x;
        Test(int x) {
            this.x = x;
        }
    }

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… QUICK SUMMARY TABLE:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

| Concept        | Purpose / Role                          |
|----------------|------------------------------------------|
| Class          | Blueprint for creating objects           |
| Object         | Instance of class                        |
| Encapsulation  | Data hiding, controlled access           |
| Inheritance    | Code reuse via parent-child relation     |
| Polymorphism   | Same action in different forms           |
| Abstraction    | Hides complexity, shows essential info   |
| Interface      | Achieves multiple inheritance, abstraction |
| Constructor    | Initializes object during creation       |
| this keyword   | Refers to current object                 |

ğŸŸ£ Java is purely object-oriented (except for primitives).
ğŸŸ£ OOPs promotes code modularity, reusability, and maintainability.


.............................................................................................................


| Specifier   | Class | Package | Subclass (in another package) | global |
| ----------- | ----- | ------- | ----------------------------- | ----- |
| `public`    | âœ…     | âœ…       | âœ…                         | âœ…   |
| `protected` | âœ…     | âœ…       | âœ…                         | âŒ   |
| (default)   | âœ…     | âœ…       | âŒ                         | âŒ   |
| `private`   | âœ…     | âŒ       | âŒ                         | âŒ   |



.............................................................................................................
// ğŸ“¦ Java Constructor â€“ Theory Summary

// â¤ A constructor is a special method used to initialize objects in Java.
// â¤ It has the same name as the class and has no return type (not even void).
// â¤ It is called automatically when an object is created using the `new` keyword.
// â¤ Constructors can be overloaded (multiple constructors with different parameters).
// â¤ If no constructor is defined, Java provides a default constructor.
// â¤ Types of Constructors:
//    - Default Constructor: Takes no parameters.
//    - Parameterized Constructor: Takes arguments to initialize fields.
//    - Copy Constructor: Initializes an object using another object (created manually).
// â¤ The `this()` keyword can be used to call one constructor from another in the same class.
// â¤ Constructors are important for setting initial values and ensuring object readiness.



........................................................................................................................
| Feature      | Shallow Copy                       | Deep Copy                        |
| ------------ | ---------------------------------- | -------------------------------- |
| Memory       | Copies references                  | Copies actual objects/arrays     |
| Independence | Not independent (linked objects)   | Fully independent                |
| Performance  | Faster (less memory usage)         | Slower (more memory used)        |
| When to use  | When shared object state is needed | When full separation is required |


ğŸ“¦ Shallow Copy vs Deep Copy in Java

ğŸ”¹ Shallow Copy:
- Copies only the references to objects.
- Original and copied objects share the same memory for referenced fields.
- Changes in one affect the other.
- Default `Object.clone()` does shallow copy.
- Suitable when shared access is acceptable.

ğŸ”¹ Deep Copy:
- Copies all fields, including new copies of referenced objects.
- Original and copied objects are fully independent.
- Changes in one do NOT affect the other.
- Requires manual copying of nested objects/arrays.
- Suitable when isolation of objects is needed.
